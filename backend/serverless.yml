service: task-processing-backend
frameworkVersion: '3' # Or your specific version

provider:
  name: aws
  runtime: nodejs18.x # Specify Node.js version
  region: us-east-1 # Or your preferred region
  httpApi: # Use HTTP API for simpler setup and lower cost
    cors: true # Enable CORS for frontend interaction
  environment: # Environment variables available to all functions
    TASKS_TABLE_NAME: ${self:custom.tasksTableName}
    TASK_QUEUE_URL: { Ref: TaskQueue } # Get URL of the TaskQueue
    TASK_DLQ_URL: { Ref: TaskDLQ }     # Get URL of the TaskDLQ
    STEP_FUNCTIONS_ARN: { Ref: TaskProcessingStateMachine } # State machine ARN
    # Use Ref: WebsocketsApi which references the default logical ID assigned by Serverless Framework
    WEBSOCKET_API_ENDPOINT: 
      Fn::Sub: 'wss://${WebsocketsApi}.execute-api.${AWS::Region}.amazonaws.com/${sls:stage}' 
    MANAGEMENT_API_ENDPOINT: 
      Fn::Sub: 'https://${WebsocketsApi}.execute-api.${AWS::Region}.amazonaws.com/${sls:stage}' 
    CONNECTIONS_TABLE_NAME: ${self:custom.connectionsTableName}

  iam:
    role:
      statements: # Permissions for all functions (can be refined per function)
        - Effect: Allow # DynamoDB Tasks Table
          Action: [dynamodb:Query, dynamodb:Scan, dynamodb:GetItem, dynamodb:PutItem, dynamodb:UpdateItem, dynamodb:DeleteItem]
          Resource:
            - Fn::GetAtt: [TasksTable, Arn]
        - Effect: Allow # DynamoDB Connections Table (for WebSockets)
          Action: [dynamodb:Query, dynamodb:Scan, dynamodb:GetItem, dynamodb:PutItem, dynamodb:UpdateItem, dynamodb:DeleteItem]
          Resource:
            - Fn::GetAtt: [ConnectionsTable, Arn]
        - Effect: Allow # SQS Send/Receive/Delete
          Action: [sqs:SendMessage, sqs:ReceiveMessage, sqs:DeleteMessage, sqs:GetQueueAttributes]
          Resource:
            - Fn::GetAtt: [TaskQueue, Arn]
            - Fn::GetAtt: [TaskDLQ, Arn]
        - Effect: Allow # Step Functions Start Execution
          Action: [states:StartExecution]
          Resource:
            - Ref: TaskProcessingStateMachine
        # Use Ref: WebsocketsApi for the implicitly created API
        - Effect: Allow # WebSocket Management
          Action: [execute-api:ManageConnections]
          Resource: 
            - Fn::Sub: 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebsocketsApi}/*'
        - Effect: Allow # DynamoDB Streams
          Action: [dynamodb:GetRecords, dynamodb:GetShardIterator, dynamodb:DescribeStream, dynamodb:ListStreams]
          Resource:
             Fn::GetAtt: [TasksTable, StreamArn] # Permission for the specific stream

custom:
  tasksTableName: ${sls:stage}-tasks-table
  connectionsTableName: ${sls:stage}-websocket-connections # Uncommented
  processTaskLambdaArn: arn:aws:lambda:${aws:region}:${aws:accountId}:function:${self:service}-${sls:stage}-processTaskLambda
  handleFailureLambdaArn: arn:aws:lambda:${aws:region}:${aws:accountId}:function:${self:service}-${sls:stage}-handleFailureLambda

functions:
  submitTaskLambda:
    handler: src/handlers/submitTask.handler
    events:
      - httpApi:
          path: /tasks
          method: post

  getTasksLambda:
    handler: src/handlers/getTasks.handler
    events:
      - httpApi:
          path: /tasks
          method: get

  startStateMachineLambda:
    handler: src/handlers/startStateMachine.handler
    events:
      - sqs:
          arn: { Fn::GetAtt: [TaskQueue, Arn] }
          batchSize: 1 # Process one task message at a time

  processTaskLambda: # Invoked by Step Function
    handler: src/handlers/processTask.handler
    # No event trigger here

  dlqMonitorLambda:
    handler: src/handlers/dlqMonitor.handler
    events:
      - sqs:
          arn: { Fn::GetAtt: [TaskDLQ, Arn] }
          batchSize: 1

  # WebSocket Handlers - Uncommented
  connectLambda:
    handler: src/handlers/websocketConnect.handler
    events:
      - websocket:
          route: $connect

  disconnectLambda:
    handler: src/handlers/websocketDisconnect.handler
    events:
      - websocket:
          route: $disconnect

  defaultHandlerLambda: 
    handler: src/handlers/websocketDefault.handler
    events:
      - websocket:
          route: $default
  
  # Lambda triggered by DynamoDB Stream to notify clients - Uncommented
  notifyClientsLambda:
    handler: src/handlers/notifyClients.handler
    events:
      - stream:
          type: dynamodb
          arn: { Fn::GetAtt: [TasksTable, StreamArn] }
          batchSize: 1
          startingPosition: LATEST
          filterPatterns:
            - eventName: [MODIFY]
              dynamodb:
                  NewImage:
                    status:
                      S: [Processed, Failed]

  handleFailureLambda: # Invoked by Step Function Catch
    handler: src/handlers/handleFailure.handler

resources:
  Resources:
    TasksTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tasksTableName}
        AttributeDefinitions:
          - AttributeName: taskId
            AttributeType: S
        KeySchema:
          - AttributeName: taskId
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST
        StreamSpecification:
          StreamViewType: NEW_IMAGE

    # Table to store WebSocket connection IDs - Uncommented
    ConnectionsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.connectionsTableName}
        AttributeDefinitions:
          - AttributeName: connectionId
            AttributeType: S
        KeySchema:
          - AttributeName: connectionId
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST

    TaskQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${sls:stage}-TaskQueue
        RedrivePolicy:
          # Use Fn::GetAtt for ARNs
          deadLetterTargetArn: { Fn::GetAtt: [TaskDLQ, Arn] }
          maxReceiveCount: 3

    TaskDLQ:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${sls:stage}-TaskDLQ

    TaskProcessingStateMachine:
      Type: AWS::StepFunctions::StateMachine
      Properties:
        StateMachineName: ${sls:stage}-TaskProcessingStateMachine
        DefinitionString: |
          {
            "Comment": "Task Processing State Machine",
            "StartAt": "ProcessTask",
            "States": {
              "ProcessTask": {
                "Type": "Task",
                "Resource": "${self:custom.processTaskLambdaArn}",
                "Parameters": { 
                  "TaskInput.$": "$", 
                  "RetryCount.$": "$$.State.RetryCount" 
                },
                "Retry": [
                  {
                    "ErrorEquals": ["States.ALL"],
                    "IntervalSeconds": 3,
                    "MaxAttempts": 3, 
                    "BackoffRate": 2.0
                  }
                ],
                "Catch": [
                  {
                    "ErrorEquals": ["States.ALL"],
                    "ResultPath": "$.errorInfo", 
                    "Next": "HandleFailureState"
                  }
                ],
                "End": true
              },
              "HandleFailureState": {
                  "Type": "Task",
                  "Resource": "${self:custom.handleFailureLambdaArn}",
                  "Parameters": {
                      "TaskInput.$": "$",
                      "ErrorInfo.$": "$.errorInfo"
                  },
                  "End": true
              }
            }
          }
        RoleArn: { Fn::GetAtt: [StateMachineExecutionRole, Arn] }

    StateMachineExecutionRole:
      Type: AWS::IAM::Role
      Properties:
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service: states.${aws:region}.amazonaws.com
              Action: sts:AssumeRole
        Policies:
          - PolicyName: StepFunctionsExecutionPolicy
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action: lambda:InvokeFunction
                  Resource:
                    - "${self:custom.processTaskLambdaArn}"
                    - "${self:custom.handleFailureLambdaArn}"

    # Role for API Gateway to invoke Lambda functions - Still needed
    TaskProcessingApiGatewayIntegrationRole:
      Type: AWS::IAM::Role
      Properties:
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service: apigateway.amazonaws.com
              Action: sts:AssumeRole
        Policies:
          - PolicyName: ApiGatewayInvokeLambdaPolicy
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action: lambda:InvokeFunction
                  Resource: # Allow invoking all relevant Lambda functions
                    - Fn::Sub: 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${self:service}-${sls:stage}-connectLambda'
                    - Fn::Sub: 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${self:service}-${sls:stage}-disconnectLambda'
                    - Fn::Sub: 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${self:service}-${sls:stage}-defaultHandlerLambda'

    # The `WebsocketsApi` resource is defined in `resources.yml`
    # The following routes, deployment, and stage are commented out for incremental deployment
    # routes:
    #   $connect: connectLambda
    #   $disconnect: disconnectLambda
    #   $default: defaultHandlerLambda
    # deploymentId: ${self:provider.websocketsApiDeploymentId}
    # stage: ${sls:stage} 